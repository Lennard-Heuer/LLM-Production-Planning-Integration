Summary of the LP Models:

1. Model: Function to optimize aggregate procution planning without workstations

Parameters:
time_horizon (int): Number of periods in the planning horizon.
profit (list of float): Profit per unit for each product (list of size equal to the number of products).
holding_costs (list of float): Holding costs per unit for each product (list of size equal to the number of products).
max_demand (list of list of float): Maximum demand for each product in each period (2D list with dimensions [products x periods]).
product_capacity (list of list of float): Production capacity for each product in each period (2D list with dimensions [products x periods]).
initial_inventory (list of float): Initial inventory for each product at the start of the first period (list of size equal to the number of products).
products_total (int): Total number of products being considered in the model.


2. Model: Function to optimize aggregate procution planning with multiple products - no extension.

Parameters:

time_horizon: Time horizon (number of periods).
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
max_demand: Maximum demand for each product in each period.
workstation_capacity: Capacity of each workstation for each period.
initial_inventory: Initial inventory for each product.
products_total: Total number of products.
workstations_total: Total number of workstations.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.


3. Model: Function to optimize aggregate procution planning with multiple products - incl. Capacitated ressorces

Parameters:

time_horizon: Time horizon (number of periods).
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
max_demand: Maximum demand for each product in each period.
workstation_capacity: Capacity of each workstation for each period.
initial_inventory: Initial inventory for each product.
products_total: Total number of products.
workstations_total: Total number of workstations.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.
ressources_total: Total number of resources.
resource_requirement: Resource requirement per product for each resource.
resource_capacity: Resource capacity available for each period.


4. Model: Function to optimize aggregate procution planning with multiple products. - incl. Capacity Reduciton Factor

Parameters:

products_total: Total number of products.
workstations_total: Total number of workstations.
time_horizon: Time horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
initial_inventory: Initial inventory for each product.
capacity_reduction_factor: Percentage of the capacity that should be used practically at max.


5. Model: Function to optimize aggregate procution planning with multiple products - incl. Backorders

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
initial_inventory: Initial inventory for each product.
back_orders_penalty: Penalty for not being able to satisfy the demand for one unit of each product.


6. Model: Function to optimize aggregate procution planning with multiple products - Overtime

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
back_orders_penalty: Penalty for not being able to satisfy the demand for one unit of each product.
overtime_cost: Cost of 1 hour of overtime at each workstation.
initial_inventory: Initial inventory for each product.


7. Model: Function to optimize aggregate procution planning with multiple products - incl. Yield loss

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
initial_inventory: Initial inventory for each product.
yield_loss: Cumulative yield loss from each station onward for each product.


8. Model: Function to Optimize Workforce Planning

Parameters:

n: Total number of workstations.
bar_t: Planning horizon (number of periods).
r: Revenue per unit.
h: Holding costs per unit.
max_demand: Maximum demand in each period.
min_sales: Minimum sales required in each period.
production_time: Production time required on each workstation.
workstation_capacity: Capacity of each workstation in each period.
initial_inventory: Initial inventory at the start of the first period.
worker_hours_per_product: Number of worker-hours required to produce one unit.
hourly_wage: Cost of regular time in dollars per worker-hour.
hourly_wage_overtime: Cost of overtime in dollars per worker-hour.
hiring_cost: Cost to increase workforce by one worker-hour per period.
layoff_cost: Cost to decrease workforce by one worker-hour per period.
initial_workers: Initial number of worker-hours available.


9. Model: Production Planning with Setup and Capacity Constraints

Parameters:

time_horizon: Total number of periods (planning horizon).
products: List of products.
workstations_total: Total number of workstations.
profit[i]: Profit per unit of product i.
holding_costs[i]: Holding cost per unit of product i.
max_demand[i][t]: Maximum demand for product i in period t.
min_sales[i][t]: Minimum sales required for product i in period t.
workstation_capacity[w][t]: Capacity of workstation w in period t.
initial_inventory[i]: Initial inventory of product i at the start of period 1.
production_time[i][w]: Time required on workstation w to produce one unit of product i.
setup_cost[i]: Setup cost for switching to product i.

----------------------------------------------------------------------------------

1. Model: Function to optimize aggregate procution planning without workstations

Parameters:
time_horizon (int): Number of periods in the planning horizon.
profit (list of float): Profit per unit for each product (list of size equal to the number of products).
holding_costs (list of float): Holding costs per unit for each product (list of size equal to the number of products).
max_demand (list of list of float): Maximum demand for each product in each period (2D list with dimensions [products x periods]).
product_capacity  (list of list of float): Production capacity for each product in each period (2D list with dimensions [products x periods]).
initial_inventory (list of float): Initial inventory for each product at the start of the first period (list of size equal to the number of products).
products_total (int): Total number of products being considered in the model.

Returns:
dict: Optimal values of decision variables and total profit.
"""
from pulp import LpMaximize, LpProblem, LpVariable, lpSum

def optimize_multi_product_production(time_horizon, profit, holding_costs, max_demand, product_capacity, initial_inventory, products_total):
    # Create the problem
    problem = LpProblem("Maximize_Profit_Multi_Product", LpMaximize)

    # Index ranges for products and periods
    products = range(products_total)
    periods = range(time_horizon)

    # Decision Variables
    Amount_produced = [[LpVariable(f"Amount_produced_product_{i}_period_{t}", lowBound=0) for t in periods] for i in products]
    Amount_sold = [[LpVariable(f"Amount_sold_product_{i}_period_{t}", lowBound=0) for t in periods] for i in products]
    Inventory = [[LpVariable(f"Inventory_product_{i}_period_{t}", lowBound=0) for t in periods] for i in products]

    # Objective Function
    profit_term = lpSum(profit[i] * Amount_sold[i][t] for i in products for t in periods)
    holding_cost_term = lpSum(holding_costs[i] * Inventory[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term

    # Constraints
    for i in products:
        for t in periods:
            # Demand constraint
            problem += Amount_sold[i][t] <= max_demand[i][t], f"Demand_Constraint_Product_{i}_Period_{t}"
            # Inventory balance constraint
            if t == 0:
                problem += Inventory[i][t] == initial_inventory[i] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_Product_{i}_Period_{t}"
            else:
                problem += Inventory[i][t] == Inventory[i][t-1] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_Product_{i}_Period_{t}"

            # Product-specific capacity constraint
            problem += Amount_produced[i][t] <= product_capacity[i][t], f"Capacity_Constraint_Product_{i}_Period_{t}"

    # Solve the problem
    problem.solve()

    # Output the results
    result = {}
    for v in problem.variables():
        result[v.name] = v.varValue
        print(f'{v.name} = {v.varValue}')

    # Extract total profit
    total_profit = sum(profit[i] * result[f"Amount_sold_product_{i}_period_{t}"] for i in products for t in periods) - \
                   sum(holding_costs[i] * result[f"Inventory_product_{i}_period_{t}"] for i in products for t in periods)
    print(f"Total Profit: {total_profit}")

    return result, total_profit


---


"""
2. Model: Function to optimize aggregate procution planning with multiple products - no extension.

Parameters:

time_horizon: Time horizon (number of periods).
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
max_demand: Maximum demand for each product in each period.
workstation_capacity: Capacity of each workstation for each period.
initial_inventory: Initial inventory for each product.
products_total: Total number of products.
workstations_total: Total number of workstations.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.


# Define indexes
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]

profit[i] = net profit from one unit of product i
holding_costs[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

from pulp import LpMaximize, LpProblem, LpVariable, lpSum, LpConstraint
def supply_chain_optimization(time_horizon, profit, holding_costs, max_demand, workstation_capacity, initial_inventory, products_total, workstations_total, min_sales, production_time):

    # Create the problem
    problem = pulp.LpProblem("Supply_Chain_Optimization", pulp.LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(products_total)
    workstations = range(workstations_total)
    periods = range(time_horizon)

    # Decision Variables
    Amount_produced = [[LpVariable(f"Amount_produced_product_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Amount_sold = [[LpVariable(f"Amount_sold_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Inventory = [[LpVariable(f"Inventory_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]

    # Objective Function
    profit_term = pulp.lpSum(profit[i] * S[i][t] for i in products for t in periods)
    holding_cost_term = pulp.lpSum(holding_costs[i] * I[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term

    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]

    # Constraints
    for i in products:
        for t in periods:
            problem += S[i][t] >= min_sales[i][t]  # Min sales constraint
            problem += S[i][t] <= max_demand[i][t]  # Max demand constraint
            if t == 1:
                problem += I[i][t] == initial_inventory[i] + X[i][t] - S[i][t]  # Inventory balance for first period
            else:
                problem += I[i][t] == I[i][t-1] + X[i][t] - S[i][t]  # Inventory balance

    for j in workstations:
        for t in periods:
            problem += pulp.lpSum(production_time[i][j] * X[i][t] for i in products) <= workstation_capacity[j][t]  # Capacity constraint

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]

    return problem, workstation_usage

---

import pulp

"""
3. Model: Function to optimize aggregate procution planning with multiple products - Capacitated ressorces

Parameters:

time_horizon: Time horizon (number of periods).
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
max_demand: Maximum demand for each product in each period.
workstation_capacity: Capacity of each workstation for each period.
initial_inventory: Initial inventory for each product.
products_total: Total number of products.
workstations_total: Total number of workstations.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.
ressources_total: Total number of resources.
resource_requirement: Resource requirement per product for each resource.
resource_capacity: Resource capacity available for each period.

# Define indexes
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]

resource_requirement[i][j] = units of resource j required per unit of product i
resource_capacity[j][t] = number of units of resource j available in period t

r[i] = net profit from one unit of product i
h[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

def supply_chain_optimization(time_horizon, profit, holding_costs, max_demand, workstation_capacity, initial_inventory, products_total, workstations_total, min_sales, production_time, ressources_total, resource_requirement, resource_capacity):

    # Create the problem
    problem = pulp.LpProblem("Supply_Chain_Optimization", pulp.LpMaximize)

    # Index ranges for products, resources, and periods
    products = range(products_total)
    workstations = range(workstations_total)
    periods = range(time_horizon)
    resources = range(ressources_total)

 # Decision Variables
    Amount_produced = [[LpVariable(f"Amount_produced_product_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Amount_sold = [[LpVariable(f"Amount_sold_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Inventory = [[LpVariable(f"Inventory_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]

    # Objective Function
    profit_term = pulp.lpSum(profit[i] * Amount_sold[i][t] for i in products for t in periods)
    holding_cost_term = pulp.lpSum(holding_costs[i] * I[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term

    # Constraints
    for i in products:
        for t in periods:
            problem += Amount_produced[i][t] >= min_sales[i][t]  # Min sales constraint
            problem += Amount_sold[i][t] <= max_demand[i][t]  # Max demand constraint
            if t == 1:
                problem += Inventory[i][t] == initial_inventory[i] + Amount_produced[i][t] - Amount_sold[i][t]  # Inventory balance for first period
            else:
                problem += Inventory[i][t] == I[i][t-1] + Amount_produced[i][t] - Amount_sold[i][t]  # Inventory balance

    for j in workstations:
        for t in periods:
            problem += pulp.lpSum(production_time[i][j] * Amount_produced[i][t] for i in products) <= workstation_capacity[j][t]  # Capacity constraint

    for j in resources:
        for t in periods:
            problem += pulp.lpSum(resource_requirement[i][j] * Amount_produced[i][t] for i in products) <= resource_capacity[j][t]  # Modified capacity constraint

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')


    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]
    add_capacity_usage = [[0] * time_horizon for _ in range(resources_total)]


    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]


    add_capacity_usage = [
        [
            (resource_requirement[i][j] * Amount_produced[i][t].varValue / resource_capacity[j][t]) * 100 if resource_capacity[j][t] > 0 else 0
            for t in periods
        ]
        for j in resources
        for i in products
    ]	

    return problem, workstation_usage, add_capacity_usage

-----

"""
4. Model: Function to optimize aggregate procution planning with multiple products. - incl. Capacity Reduciton Factor

Parameters:

products_total: Total number of products.
workstations_total: Total number of workstations.
time_horizon: Time horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales required for each product in each period.
production_time: Production time required for each product on each workstation.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit per unit for each product.
holding_costs: Holding costs per unit for each product.
initial_inventory: Initial inventory for each product.
capacity_reduction_factor: Percentage of the capacity that should be used practically at max.

# Define indexes
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]
capacity_reduction_factor[j] = Percentage of the capacity that should be used practically at max
r[i] = net profit from one unit of product i
h[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

from pulp import LpMaximize, LpProblem, LpVariable, lpSum, LpConstraint

def supply_chain_optimization_extended(
    products_total, workstations_total, time_horizon, max_demand, min_sales, production_time, workstation_capacity,
    profit, holding_costs, initial_inventory, capacity_reduction_factor
):
    # Create the problem
    problem = LpProblem("Supply_Chain_Optimization_Extended", LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(products_total)
    workstations = range(workstations_total)
    periods = range(time_horizon)

    # Decision Variables
    Amount_produced = [[LpVariable(f"Amount_produced_product_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Amount_sold = [[LpVariable(f"Amount_sold_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Inventory = [[LpVariable(f"Inventory_period_{i}, period_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]

    # Objective Function
    profit_term = lpSum(profit[i] * Amount_sold[i][t] for i in products for t in periods)
    holding_cost_term = lpSum(holding_cost[i] * Inventory[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term

    # Constraints
    for i in products:
        for t in periods:
            # Sales constraints
            problem += Amount_sold[i][t] >= min_sales[i][t], f"Min_Sales_{i}_{t}"
            problem += Amount_sold[i][t] <= max_demand[i][t], f"Max_Demand_{i}_{t}"
            # Inventory balance constraint
            if t == 1:
                problem += Inventory[i][t] == initial_inventory[i] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_{i}_{t}"
            else:
                problem += Inventory[i][t] == Inventory[i][t-1] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_{i}_{t}"

    for j in workstations:
        for t in periods:
            # Adjusted capacity constraint
            problem += lpSum(production_time[i][j] * Amount_produced[i][t] for i in products) <= \
                       workstation_capacity[j][t] * capacity_reduction_factor, \
                       f"Adjusted_Capacity_{j}_{t}"

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]

    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]

    return problem, workstation_usage

---

"""
5. Model: Function to optimize aggregate procution planning with multiple products - incl. Backorders

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
initial_inventory: Initial inventory for each product.
back_orders_penalty: Penalty for not being able to satisfy the demand for one unit of each product.

# Define indexes:
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters:
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]
I_minus[i][t] = represents the number of backorders carried from period t to t + 1
I_plus[i][t] = represents the inventory of product i carried from period t to t + 1
back_orders_pentaly[i] = penalty for not being able to satisfy the demand for one unit of product i

r[i] = net profit from one unit of product i
h[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

def supply_chain_optimization_new(m, n, bar_t, max_demand, min_sales, production_time, workstation_capacity, profit, holding_cost, initial_inventory, back_orders_pentaly):
    # Create the problem
    problem = pulp.LpProblem("New_Supply_Chain_Optimization", pulp.LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(m)
    workstations = range(n)
    periods = range(bar_t)

    # Decision Variables
    X = pulp.LpVariable.dicts("X", (products, periods), lowBound=0, cat='Continuous')
    S = pulp.LpVariable.dicts("S", (products, periods), lowBound=0, cat='Continuous')
    I_plus = pulp.LpVariable.dicts("I_plus", (products, periods), lowBound=0, cat='Continuous')
    I_minus = pulp.LpVariable.dicts("I_minus", (products, periods), lowBound=0, cat='Continuous')

    # Objective Function
    profit_term = pulp.lpSum(profit[i] * S[i][t] for i in products for t in periods)
    holding_cost_term = pulp.lpSum(holding_cost[i] * I_plus[i][t] for i in products for t in periods)
    backorders_penalty_term = pulp.lpSum(back_orders_pentaly[i] * I_plus[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term - backorders_penalty_term

    # Constraints
    for i in products:
        for t in periods:
            problem += S[i][t] >= min_sales[i][t]  # Min demand constraint
            problem += S[i][t] <= max_demand[i][t]       # Max demand constraint
            problem += I_plus[i][t] - I_minus[i][t] == (I_plus[i][t-1] if t > 1 else initial_inventory[i]) + X[i][t] - S[i][t]  # Inventory balance
            problem += X[i][t] >= 0                 # Non-negativity constraint for production
            problem += S[i][t] >= 0                 # Non-negativity constraint for sales
            problem += I_plus[i][t] >= 0            # Non-negativity constraint for positive inventory
            problem += I_minus[i][t] >= 0           # Non-negativity constraint for negative inventory

    for j in workstations:
        for t in periods:
            problem += pulp.lpSum(production_time[i][j] * X[i][t] for i in products) <= workstation_capacity[j][t]  # Capacity constraint

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]

    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]

    return problem, workstation_usage

---

"""
6. Model: Function to optimize aggregate procution planning with multiple products - Overtime

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
back_orders_penalty: Penalty for not being able to satisfy the demand for one unit of each product.
overtime_cost: Cost of 1 hour of overtime at each workstation.
initial_inventory: Initial inventory for each product.

# Define indexes:
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters:
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]

overtime_cost[j] = cost of 1 hour of overtime at workstation j ; a cost parameter
overtime[j][t] = overtime taken at workstation j in period t

r[i] = net profit from one unit of product i
h[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

from pulp import LpMaximize, LpProblem, LpVariable, lpSum

def advanced_supply_chain_optimization(m, n, bar_t, max_demand, min_sales, production_time, workstation_capacity, profit, holding_cost, back_orders_pentaly, overtime_cost, initial_inventory):
    # Create the problem
    problem = LpProblem("Advanced_Supply_Chain_Optimization", LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(m)
    workstations = range(n )
    periods = range(bar_t)

    # Decision Variables
    X = pulp.LpVariable.dicts("X", (products, periods), lowBound=0, cat='Continuous')
    S = pulp.LpVariable.dicts("S", (products, periods), lowBound=0, cat='Continuous')
    I_plus = pulp.LpVariable.dicts("I_plus", (products, periods), lowBound=0, cat='Continuous')
    I_minus = pulp.LpVariable.dicts("I_minus", (products, periods), lowBound=0, cat='Continuous')
    O = pulp.LpVariable.dicts("O", (workstations, periods), lowBound=0, cat='Continuous')

    # Objective Function
    profit_term = lpSum(profit[i] * S[i][t] for i in products for t in periods)
    holding_cost_term = lpSum(holding_cost[i] * I_plus[i][t] for i in products for t in periods)
    penalty_cost_term = lpSum(back_orders_pentaly[i] * I_minus[i][t] for i in products for t in periods)
    overtime_cost_term = lpSum(overtime_cost[j] * O[j][t] for j in workstations for t in periods)
    problem += profit_term - holding_cost_term - penalty_cost_term - overtime_cost_term

    # Constraints
    for i in products:
        for t in periods:
            problem += S[i][t] >= min_sales[i][t]
            problem += S[i][t] <= max_demand[i][t]
            if t == 0:
                problem += I_plus[i][t] - I_minus[i][t] == initial_inventory[i] + X[i][t] - S[i][t]
            else:
                problem += I_plus[i][t] - I_minus[i][t] == I_plus[i][t-1] - I_minus[i][t-1] + X[i][t] - S[i][t]

    for j in workstations:
        for t in periods:
            problem += lpSum(production_time[i][j] * X[i][t] for i in products) <= workstation_capacity[j][t] + O[j][t]


    # Additional constraints for positive and negative inventory
    for i in products:
        for t in periods:
            problem += I_plus[i][t] >= 0
            problem += I_minus[i][t] >= 0

    # Overtime constraints
    for j in workstations:
        for t in periods:
            problem += O[j][t] >= 0

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]

    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]

    return problem, workstation_usage

---

"""
7. Model: Function to optimize aggregate procution planning with multiple products - Yield loss

Parameters:

m: Total number of products.
n: Total number of workstations.
bar_t: Planning horizon (number of periods).
max_demand: Maximum demand for each product in each period.
min_sales: Minimum sales allowed for each product in each period.
production_time: Time required on each workstation to produce one unit of each product.
workstation_capacity: Capacity of each workstation for each period.
profit: Net profit from one unit of each product.
holding_cost: Cost to hold one unit of each product for one period.
initial_inventory: Initial inventory for each product.
yield_loss: Cumulative yield loss from each station onward for each product.

# Define indexes:
i = an index of product, i = 1, . . . ,m, so m represents total number of products
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

# Define the parameters:
max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

production_time[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]

yield_loss[i][j] = cumulative yield from station j onward (including station j) for product i

r[i] = net profit from one unit of product i
h[i] = cost to hold one unit of product i for one period t

# Define the Decision Variables:
X[i][t] = amount of product i produced in period t
S[i][t] = amount of product i sold in period t
I[i][t] = inventory of product i at end of period t (Ii0 is given as data)
"""

def supply_chain_optimization(m, n, bar_t, max_demand, min_sales, production_time, workstation_capacity, profit, holding_cost, initial_inventory, yield_loss):
    # Create the problem
    problem = pulp.LpProblem("Supply_Chain_Optimization", pulp.LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(m)
    workstations = range(n)
    periods = range(bar_t)

    # Decision Variables
    X = pulp.LpVariable.dicts("X", (products, periods), lowBound=0, cat='Continuous')
    S = pulp.LpVariable.dicts("S", (products, periods), lowBound=0, cat='Continuous')
    I = pulp.LpVariable.dicts("I", (products, periods), lowBound=0, cat='Continuous')

    # Objective Function
    profit_term = pulp.lpSum(profit[i] * S[i][t] for i in products for t in periods)
    holding_cost_term = pulp.lpSum(holding_cost[i] * I[i][t] for i in products for t in periods)
    problem += profit_term - holding_cost_term

    # Constraints
    for i in products:
        for t in periods:
            problem += S[i][t] >= min_sales[i][t]  # Min sales constraint
            problem += S[i][t] <= max_demand[i][t]  # Max demand constraint
            if t == 0:
                problem += I[i][t] == initial_inventory[i] + X[i][t] - S[i][t]  # Inventory balance for first period
            else:
                problem += I[i][t] == I[i][t-1] + X[i][t] - S[i][t]  # Inventory balance

    for j in workstations:
        for t in periods:
            problem += lpSum(production_time[i][j] * X[i][t] / yield_loss[i][j] for i in products) <= workstation_capacity[j][t], f"Resource_Capacity_{j}_{t}"

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    # Initialize lists to store usage values
    workstation_usage = [[0] * time_horizon for _ in range(workstations_total)]

    workstation_usage = [
        [
            (sum(production_time[i][j] * X[i][t].varValue for i in products) / workstation_capacity[j][t]) * 100
            for t in periods
        ]
        for j in workstations
    ]

    return problem, workstation_usage

---

"""
8. Model: Function to Optimize Workforce Planning

Parameters:

n: Total number of workstations.
bar_t: Planning horizon (number of periods).
r: Revenue per unit.
h: Holding costs per unit.
max_demand: Maximum demand in each period.
min_sales: Minimum sales required in each period.
production_time: Production time required on each workstation.
workstation_capacity: Capacity of each workstation in each period.
initial_inventory: Initial inventory at the start of the first period.
worker_hours_per_product: Number of worker-hours required to produce one unit.
hourly_wage: Cost of regular time in dollars per worker-hour.
hourly_wage_overtime: Cost of overtime in dollars per worker-hour.
hiring_cost: Cost to increase workforce by one worker-hour per period.
layoff_cost: Cost to decrease workforce by one worker-hour per period.
initial_workers: Initial number of worker-hours available.

j = an index of workstation, j = 1, . . . , n, so n represents total
number of workstations
t = an index of period, t = 1, . . . , ¯t, so ¯t represents planning horizon

max_demand[i][t] = maximum demand for product i in period t
min_sales[i][t] = minimum sales allowed of product i in period t

worker_hours_per_product[j] = number of worker-hours required to produce one unit of product
time_on_workstation[i][j] = time required on workstation j to produce one unit of product i
workstation_capacity[j][t] = capacity of workstation j in period t in units consistent with those used to define production_time[i][j]

hourly_wage = cost of regular time in dollars per worker-hour
hourly_wage_overtime = cost of overtime in dollars per worker-hour
hiring_cost = cost to increase workforce by one worker-hour per period
layoff_cost = cost to decrease workforce by one worker-hour per period

X[t] = amount produced in period t
S[t] = amount sold in period t
I[t] = inventory at end of t (I0 is given as data)
W[t] = workforce in period t in worker-hours of regular time (W0 is given as data)
H[t] = increase (hires) in workforce from period t-1 to t in worker-hours
F[t] = decrease (fires) in workforce from period t-1 to t in worker-hours
O[t] = overtime in period t in hours
"""

import pulp

def supply_chain_optimization_extended(n, bar_t, r, h, max_demand, min_sales, production_time, workstation_capacity, initial_inventory,
                                        worker_hours_per_product, hourly_wage, hourly_wage_overtime, hiring_cost, layoff_cost, initial_workers):
    # Create the problem
    problem = pulp.LpProblem("Extended_Supply_Chain_Optimization", pulp.LpMaximize)

    # Index ranges for products, workstations, and periods
    # workstations = range(1, n + 1)
    # periods = range(1, bar_t + 1)

    # Decision Variables
    X = [pulp.LpVariable(f"X_{t}", lowBound=0) for t in range(bar_t)]
    S = [pulp.LpVariable(f"S_{t}", lowBound=0) for t in range(bar_t)]
    I = [pulp.LpVariable(f"I_{t}", lowBound=0) for t in range(bar_t)]
    O = [pulp.LpVariable(f"O_{t}", lowBound=0) for t in range(bar_t)]
    W = [pulp.LpVariable(f"W_{t}", lowBound=0) for t in range(bar_t)]
    H = [pulp.LpVariable(f"H_{t}", lowBound=0) for t in range(bar_t)]
    F = [pulp.LpVariable(f"F_{t}", lowBound=0) for t in range(bar_t)]

    # Objective Function
    problem += pulp.lpSum([r * S[t] - h * I[t] - hourly_wage * W[t] - hourly_wage_overtime * O[t] - hiring_cost * H[t] - layoff_cost * F[t]
                           for t in range(bar_t)])

    # Constraints
    for t in range(bar_t):
        problem += S[t] >= min_sales[t]  # Min demand constraint
        problem += S[t] <= max_demand[t]  # Max demand constraint
        if t == 1:
            problem += I[t] == initial_inventory + X[t] - S[t]  # Inventory balance for first period
            problem += W[t] == initial_workers + H[t] - F[t]  # Work balance for first period
        else:
            problem += I[t] == I[t-1] + X[t] - S[t]  # Inventory balance
            problem += W[t] == W[t-1] + H[t] - F[t]  # Work balance

    for j in range(n):
        for t in range(bar_t):
            problem += production_time[j] * X[t] <= workstation_capacity[j][t]  # Capacity constraint

    for t in range(bar_t):
        problem += worker_hours_per_product * X[t] <= W[t] + O[t]  # Work and Overtime constraint

    # Solve the problem
    problem.solve()

    # Output the results
    for v in problem.variables():
        print(f'{v.name} = {v.varValue}')

    # Initialize lists to store usage values
    capacity_usage = [[0] * bar_t for _ in range(n)]
    workforce_usage = [0] * bar_t

    # Calculate capacity usage as a percentage of capacity
    for j in range(n):
        for t in range(bar_t):
            if workstation_capacity[j][t] > 0:
                capacity_usage[j][t] = (production_time[j] * X[t].varValue / workstation_capacity[j][t]) * 100

    # Calculate workforce usage as a percentage of available workforce (regular + overtime)
    for t in range(bar_t):
        if (W[t].varValue + O[t].varValue) > 0:
            workforce_usage[t] = (worker_hours_per_product * X[t].varValue / (W[t].varValue + O[t].varValue)) * 100

    return problem, capacity_usage, workforce_usage

-------------

"""
9. Model: Production Planning with Setup and Capacity Constraints

Parameters:

time_horizon: Total number of periods (planning horizon).
products: List of products.
workstations_total: Total number of workstations.

profit[i]: Profit per unit of product i.
holding_costs[i]: Holding cost per unit of product i.
max_demand[i][t]: Maximum demand for product i in period t.
min_sales[i][t]: Minimum sales required for product i in period t.
workstation_capacity[w][t]: Capacity of workstation w in period t.
initial_inventory[i]: Initial inventory of product i at the start of period 1.

production_time[i][w]: Time required on workstation w to produce one unit of product i.
setup_cost[i]: Setup cost for switching to product i.

Decision Variables:

X[i][t]: Amount of product i produced in period t.
S[i][t]: Amount of product i sold in period t.
I[i][t]: Inventory of product i at the end of period t.
Y[i][t]: Binary setup variable for product i in period t (1 if setup is active, 0 otherwise).

Objective:

Maximize the total profit across all products and periods, minus holding costs and setup costs.

Constraints:

1. Sales Constraints: Ensure that the sales of each product are within the minimum and maximum demand bounds.
2. Inventory Balance: Ensure that inventory in each period reflects production, previous inventory, and sales.
3. Capacity Constraints: Ensure that total production does not exceed the capacity of the workstations in each period.
4. Production Setup Constraints: Production is allowed only if the setup variable is active for the product in the period.
5. Unique Setup Constraint: Only one product can be set up at any given time.
"""

from pulp import LpMaximize, LpProblem, LpVariable, lpSum, LpBinary, LpStatus

def production_optimization_with_setup(
    time_horizon, products, workstations_total, profit, holding_costs, max_demand,
    min_sales, workstation_capacity, initial_inventory, production_time, setup_cost
):
    # Initialize the model
    problem = LpProblem("Production_Optimization_with_Setup", LpMaximize)

    # Decision Variables
    X = [[LpVariable(f"X_{p}_{t}", lowBound=0) for t in range(time_horizon)] for p in range(len(products))]  # Production amounts
    S = [[LpVariable(f"S_{p}_{t}", lowBound=0) for t in range(time_horizon)] for p in range(len(products))]  # Sales amounts
    I = [[LpVariable(f"I_{p}_{t}", lowBound=0) for t in range(time_horizon)] for p in range(len(products))]  # Inventory levels
    Y = [[LpVariable(f"Y_{p}_{t}", cat=LpBinary) for t in range(time_horizon)] for p in range(len(products))]  # Setup decision

    # Objective Function: Maximize profit minus holding and setup costs
    profit_term = lpSum(profit[p] * S[p][t] for p in range(len(products)) for t in range(time_horizon))
    holding_cost_term = lpSum(holding_costs[p] * I[p][t] for p in range(len(products)) for t in range(time_horizon))
    setup_cost_term = lpSum(setup_cost[p] * Y[p][t] for p in range(len(products)) for t in range(time_horizon))
    problem += profit_term - holding_cost_term - setup_cost_term

    # Constraints
    for p in range(len(products)):
        for t in range(time_horizon):
            # Sales Constraints: Ensure sales are within minimum and maximum bounds
            problem += S[p][t] >= min_sales[p][t]
            problem += S[p][t] <= max_demand[p][t]

            # Inventory Balance Constraints
            if t == 0:
                problem += I[p][t] == initial_inventory[p] + X[p][t] - S[p][t]
            else:
                problem += I[p][t] == I[p][t - 1] + X[p][t] - S[p][t]

            # Production Setup Constraints
            problem += X[p][t] <= Y[p][t] * max_demand[p][t]

    # Capacity Constraints
    for w in range(workstations_total):
        for t in range(time_horizon):
            problem += lpSum(production_time[p][w] * X[p][t] for p in range(len(products))) <= workstation_capacity[w][t]

    # Unique Setup Constraint: Only one product can be set up at any given time
    for t in range(time_horizon):
        problem += lpSum(Y[p][t] for p in range(len(products))) <= 1

    # Solve the problem
    problem.solve()

    # Collect Results
    Produced = [[X[p][t].varValue for t in range(time_horizon)] for p in range(len(products))]
    Sold = [[S[p][t].varValue for t in range(time_horizon)] for p in range(len(products))]
    Inventory = [[I[p][t].varValue for t in range(time_horizon)] for p in range(len(products))]
    Setup = [[Y[p][t].varValue for t in range(time_horizon)] for p in range(len(products))]
    Profit = problem.objective.value()

    # Calculate workstation usage as a percentage
    workstation_usage = [
        [
            sum(production_time[p][w] * Produced[p][t] / workstation_capacity[w][t] * 100 if capacity[w][t] > 0 else 0
                for p in range(len(products)))
            for t in range(time_horizon)
        ]
        for w in range(workstations_total)
    ]

    return problem, workstation_usage
